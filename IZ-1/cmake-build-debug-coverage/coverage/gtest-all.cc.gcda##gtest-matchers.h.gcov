        -:    0:Source:/mnt/c/Users/xpewa/CLionProjects/Technopark-IZ/IZ-1/Google_tests/lib/googletest-master/googletest/include/gtest/gtest-matchers.h
        -:    0:Graph:/mnt/c/Users/xpewa/CLionProjects/Technopark-IZ/IZ-1/cmake-build-debug-coverage/Google_tests/lib/googletest-master/googletest/CMakeFiles/gtest.dir/src/gtest-all.cc.gcno
        -:    0:Data:/mnt/c/Users/xpewa/CLionProjects/Technopark-IZ/IZ-1/cmake-build-debug-coverage/Google_tests/lib/googletest-master/googletest/CMakeFiles/gtest.dir/src/gtest-all.cc.gcda
        -:    0:Runs:1
        -:    1:// Copyright 2007, Google Inc.
        -:    2:// All rights reserved.
        -:    3://
        -:    4:// Redistribution and use in source and binary forms, with or without
        -:    5:// modification, are permitted provided that the following conditions are
        -:    6:// met:
        -:    7://
        -:    8://     * Redistributions of source code must retain the above copyright
        -:    9:// notice, this list of conditions and the following disclaimer.
        -:   10://     * Redistributions in binary form must reproduce the above
        -:   11:// copyright notice, this list of conditions and the following disclaimer
        -:   12:// in the documentation and/or other materials provided with the
        -:   13:// distribution.
        -:   14://     * Neither the name of Google Inc. nor the names of its
        -:   15:// contributors may be used to endorse or promote products derived from
        -:   16:// this software without specific prior written permission.
        -:   17://
        -:   18:// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
        -:   19:// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
        -:   20:// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
        -:   21:// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
        -:   22:// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
        -:   23:// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
        -:   24:// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
        -:   25:// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
        -:   26:// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   27:// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
        -:   28:// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   29:
        -:   30:// The Google C++ Testing and Mocking Framework (Google Test)
        -:   31://
        -:   32:// This file implements just enough of the matcher interface to allow
        -:   33:// EXPECT_DEATH and friends to accept a matcher argument.
        -:   34:
        -:   35:// IWYU pragma: private, include "testing/base/public/gunit.h"
        -:   36:// IWYU pragma: friend third_party/googletest/googlemock/.*
        -:   37:// IWYU pragma: friend third_party/googletest/googletest/.*
        -:   38:
        -:   39:#ifndef GTEST_INCLUDE_GTEST_GTEST_MATCHERS_H_
        -:   40:#define GTEST_INCLUDE_GTEST_GTEST_MATCHERS_H_
        -:   41:
        -:   42:#include <memory>
        -:   43:#include <ostream>
        -:   44:#include <string>
        -:   45:#include <type_traits>
        -:   46:
        -:   47:#include "gtest/gtest-printers.h"
        -:   48:#include "gtest/internal/gtest-internal.h"
        -:   49:#include "gtest/internal/gtest-port.h"
        -:   50:
        -:   51:// MSVC warning C5046 is new as of VS2017 version 15.8.
        -:   52:#if defined(_MSC_VER) && _MSC_VER >= 1915
        -:   53:#define GTEST_MAYBE_5046_ 5046
        -:   54:#else
        -:   55:#define GTEST_MAYBE_5046_
        -:   56:#endif
        -:   57:
        -:   58:GTEST_DISABLE_MSC_WARNINGS_PUSH_(
        -:   59:    4251 GTEST_MAYBE_5046_ /* class A needs to have dll-interface to be used by
        -:   60:                              clients of class B */
        -:   61:    /* Symbol involving type with internal linkage not defined */)
        -:   62:
        -:   63:namespace testing {
        -:   64:
        -:   65:// To implement a matcher Foo for type T, define:
        -:   66://   1. a class FooMatcherImpl that implements the
        -:   67://      MatcherInterface<T> interface, and
        -:   68://   2. a factory function that creates a Matcher<T> object from a
        -:   69://      FooMatcherImpl*.
        -:   70://
        -:   71:// The two-level delegation design makes it possible to allow a user
        -:   72:// to write "v" instead of "Eq(v)" where a Matcher is expected, which
        -:   73:// is impossible if we pass matchers by pointers.  It also eases
        -:   74:// ownership management as Matcher objects can now be copied like
        -:   75:// plain values.
        -:   76:
        -:   77:// MatchResultListener is an abstract class.  Its << operator can be
        -:   78:// used by a matcher to explain why a value matches or doesn't match.
        -:   79://
        -:   80:class MatchResultListener {
        -:   81: public:
        -:   82:  // Creates a listener object with the given underlying ostream.  The
        -:   83:  // listener does not own the ostream, and does not dereference it
        -:   84:  // in the constructor or destructor.
    #####:   85:  explicit MatchResultListener(::std::ostream* os) : stream_(os) {}
        -:   86:  virtual ~MatchResultListener() = 0;  // Makes this class abstract.
        -:   87:
        -:   88:  // Streams x to the underlying ostream; does nothing if the ostream
        -:   89:  // is NULL.
        -:   90:  template <typename T>
        -:   91:  MatchResultListener& operator<<(const T& x) {
        -:   92:    if (stream_ != nullptr) *stream_ << x;
        -:   93:    return *this;
        -:   94:  }
        -:   95:
        -:   96:  // Returns the underlying ostream.
        -:   97:  ::std::ostream* stream() { return stream_; }
        -:   98:
        -:   99:  // Returns true if and only if the listener is interested in an explanation
        -:  100:  // of the match result.  A matcher's MatchAndExplain() method can use
        -:  101:  // this information to avoid generating the explanation when no one
        -:  102:  // intends to hear it.
        -:  103:  bool IsInterested() const { return stream_ != nullptr; }
        -:  104:
        -:  105: private:
        -:  106:  ::std::ostream* const stream_;
        -:  107:
        -:  108:  GTEST_DISALLOW_COPY_AND_ASSIGN_(MatchResultListener);
        -:  109:};
        -:  110:
    #####:  111:inline MatchResultListener::~MatchResultListener() {
    #####:  112:}
------------------
_ZN7testing19MatchResultListenerD0Ev:
    #####:  111:inline MatchResultListener::~MatchResultListener() {
    #####:  112:}
    %%%%%:  112-block  0
------------------
_ZN7testing19MatchResultListenerD2Ev:
    #####:  111:inline MatchResultListener::~MatchResultListener() {
    #####:  112:}
------------------
        -:  113:
        -:  114:// An instance of a subclass of this knows how to describe itself as a
        -:  115:// matcher.
        -:  116:class MatcherDescriberInterface {
        -:  117: public:
    #####:  118:  virtual ~MatcherDescriberInterface() {}
------------------
_ZN7testing25MatcherDescriberInterfaceD0Ev:
    #####:  118:  virtual ~MatcherDescriberInterface() {}
    %%%%%:  118-block  0
------------------
_ZN7testing25MatcherDescriberInterfaceD2Ev:
    #####:  118:  virtual ~MatcherDescriberInterface() {}
------------------
        -:  119:
        -:  120:  // Describes this matcher to an ostream.  The function should print
        -:  121:  // a verb phrase that describes the property a value matching this
        -:  122:  // matcher should have.  The subject of the verb phrase is the value
        -:  123:  // being matched.  For example, the DescribeTo() method of the Gt(7)
        -:  124:  // matcher prints "is greater than 7".
        -:  125:  virtual void DescribeTo(::std::ostream* os) const = 0;
        -:  126:
        -:  127:  // Describes the negation of this matcher to an ostream.  For
        -:  128:  // example, if the description of this matcher is "is greater than
        -:  129:  // 7", the negated description could be "is not greater than 7".
        -:  130:  // You are not required to override this when implementing
        -:  131:  // MatcherInterface, but it is highly advised so that your matcher
        -:  132:  // can produce good error messages.
    #####:  133:  virtual void DescribeNegationTo(::std::ostream* os) const {
    #####:  134:    *os << "not (";
    %%%%%:  134-block  0
    #####:  135:    DescribeTo(os);
    #####:  136:    *os << ")";
    #####:  137:  }
        -:  138:};
        -:  139:
        -:  140:// The implementation of a matcher.
        -:  141:template <typename T>
        -:  142:class MatcherInterface : public MatcherDescriberInterface {
        -:  143: public:
        -:  144:  // Returns true if and only if the matcher matches x; also explains the
        -:  145:  // match result to 'listener' if necessary (see the next paragraph), in
        -:  146:  // the form of a non-restrictive relative clause ("which ...",
        -:  147:  // "whose ...", etc) that describes x.  For example, the
        -:  148:  // MatchAndExplain() method of the Pointee(...) matcher should
        -:  149:  // generate an explanation like "which points to ...".
        -:  150:  //
        -:  151:  // Implementations of MatchAndExplain() should add an explanation of
        -:  152:  // the match result *if and only if* they can provide additional
        -:  153:  // information that's not already present (or not obvious) in the
        -:  154:  // print-out of x and the matcher's description.  Whether the match
        -:  155:  // succeeds is not a factor in deciding whether an explanation is
        -:  156:  // needed, as sometimes the caller needs to print a failure message
        -:  157:  // when the match succeeds (e.g. when the matcher is used inside
        -:  158:  // Not()).
        -:  159:  //
        -:  160:  // For example, a "has at least 10 elements" matcher should explain
        -:  161:  // what the actual element count is, regardless of the match result,
        -:  162:  // as it is useful information to the reader; on the other hand, an
        -:  163:  // "is empty" matcher probably only needs to explain what the actual
        -:  164:  // size is when the match fails, as it's redundant to say that the
        -:  165:  // size is 0 when the value is already known to be empty.
        -:  166:  //
        -:  167:  // You should override this method when defining a new matcher.
        -:  168:  //
        -:  169:  // It's the responsibility of the caller (Google Test) to guarantee
        -:  170:  // that 'listener' is not NULL.  This helps to simplify a matcher's
        -:  171:  // implementation when it doesn't care about the performance, as it
        -:  172:  // can talk to 'listener' without checking its validity first.
        -:  173:  // However, in order to implement dummy listeners efficiently,
        -:  174:  // listener->stream() may be NULL.
        -:  175:  virtual bool MatchAndExplain(T x, MatchResultListener* listener) const = 0;
        -:  176:
        -:  177:  // Inherits these methods from MatcherDescriberInterface:
        -:  178:  //   virtual void DescribeTo(::std::ostream* os) const = 0;
        -:  179:  //   virtual void DescribeNegationTo(::std::ostream* os) const;
        -:  180:};
        -:  181:
        -:  182:namespace internal {
        -:  183:
        -:  184:// Converts a MatcherInterface<T> to a MatcherInterface<const T&>.
        -:  185:template <typename T>
        -:  186:class MatcherInterfaceAdapter : public MatcherInterface<const T&> {
        -:  187: public:
        -:  188:  explicit MatcherInterfaceAdapter(const MatcherInterface<T>* impl)
        -:  189:      : impl_(impl) {}
        -:  190:  ~MatcherInterfaceAdapter() override { delete impl_; }
        -:  191:
        -:  192:  void DescribeTo(::std::ostream* os) const override { impl_->DescribeTo(os); }
        -:  193:
        -:  194:  void DescribeNegationTo(::std::ostream* os) const override {
        -:  195:    impl_->DescribeNegationTo(os);
        -:  196:  }
        -:  197:
        -:  198:  bool MatchAndExplain(const T& x,
        -:  199:                       MatchResultListener* listener) const override {
        -:  200:    return impl_->MatchAndExplain(x, listener);
        -:  201:  }
        -:  202:
        -:  203: private:
        -:  204:  const MatcherInterface<T>* const impl_;
        -:  205:
        -:  206:  GTEST_DISALLOW_COPY_AND_ASSIGN_(MatcherInterfaceAdapter);
        -:  207:};
        -:  208:
        -:  209:struct AnyEq {
        -:  210:  template <typename A, typename B>
    #####:  211:  bool operator()(const A& a, const B& b) const { return a == b; }
    %%%%%:  211-block  0
        -:  212:};
        -:  213:struct AnyNe {
        -:  214:  template <typename A, typename B>
        -:  215:  bool operator()(const A& a, const B& b) const { return a != b; }
        -:  216:};
        -:  217:struct AnyLt {
        -:  218:  template <typename A, typename B>
        -:  219:  bool operator()(const A& a, const B& b) const { return a < b; }
        -:  220:};
        -:  221:struct AnyGt {
        -:  222:  template <typename A, typename B>
        -:  223:  bool operator()(const A& a, const B& b) const { return a > b; }
        -:  224:};
        -:  225:struct AnyLe {
        -:  226:  template <typename A, typename B>
        -:  227:  bool operator()(const A& a, const B& b) const { return a <= b; }
        -:  228:};
        -:  229:struct AnyGe {
        -:  230:  template <typename A, typename B>
        -:  231:  bool operator()(const A& a, const B& b) const { return a >= b; }
        -:  232:};
        -:  233:
        -:  234:// A match result listener that ignores the explanation.
        -:  235:class DummyMatchResultListener : public MatchResultListener {
        -:  236: public:
    #####:  237:  DummyMatchResultListener() : MatchResultListener(nullptr) {}
    %%%%%:  237-block  0
        -:  238:
        -:  239: private:
        -:  240:  GTEST_DISALLOW_COPY_AND_ASSIGN_(DummyMatchResultListener);
        -:  241:};
        -:  242:
        -:  243:// A match result listener that forwards the explanation to a given
        -:  244:// ostream.  The difference between this and MatchResultListener is
        -:  245:// that the former is concrete.
        -:  246:class StreamMatchResultListener : public MatchResultListener {
        -:  247: public:
        -:  248:  explicit StreamMatchResultListener(::std::ostream* os)
        -:  249:      : MatchResultListener(os) {}
        -:  250:
        -:  251: private:
        -:  252:  GTEST_DISALLOW_COPY_AND_ASSIGN_(StreamMatchResultListener);
        -:  253:};
        -:  254:
        -:  255:// An internal class for implementing Matcher<T>, which will derive
        -:  256:// from it.  We put functionalities common to all Matcher<T>
        -:  257:// specializations here to avoid code duplication.
        -:  258:template <typename T>
    #####:  259:class MatcherBase {
------------------
_ZN7testing8internal11MatcherBaseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEaSEOS8_:
    #####:  259:class MatcherBase {
    %%%%%:  259-block  0
------------------
_ZN7testing8internal11MatcherBaseIRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEaSEOSA_:
    #####:  259:class MatcherBase {
    %%%%%:  259-block  0
------------------
        -:  260: public:
        -:  261:  // Returns true if and only if the matcher matches x; also explains the
        -:  262:  // match result to 'listener'.
    #####:  263:  bool MatchAndExplain(const T& x, MatchResultListener* listener) const {
    #####:  264:    return impl_->MatchAndExplain(x, listener);
    %%%%%:  264-block  0
        -:  265:  }
        -:  266:
        -:  267:  // Returns true if and only if this matcher matches x.
    #####:  268:  bool Matches(const T& x) const {
    #####:  269:    DummyMatchResultListener dummy;
    %%%%%:  269-block  0
    $$$$$:  269-block  1
    #####:  270:    return MatchAndExplain(x, &dummy);
    %%%%%:  270-block  0
    %%%%%:  270-block  1
        -:  271:  }
        -:  272:
        -:  273:  // Describes this matcher to an ostream.
    #####:  274:  void DescribeTo(::std::ostream* os) const { impl_->DescribeTo(os); }
    %%%%%:  274-block  0
        -:  275:
        -:  276:  // Describes the negation of this matcher to an ostream.
        -:  277:  void DescribeNegationTo(::std::ostream* os) const {
        -:  278:    impl_->DescribeNegationTo(os);
        -:  279:  }
        -:  280:
        -:  281:  // Explains why x matches, or doesn't match, the matcher.
        -:  282:  void ExplainMatchResultTo(const T& x, ::std::ostream* os) const {
        -:  283:    StreamMatchResultListener listener(os);
        -:  284:    MatchAndExplain(x, &listener);
        -:  285:  }
        -:  286:
        -:  287:  // Returns the describer for this matcher object; retains ownership
        -:  288:  // of the describer, which is only guaranteed to be alive when
        -:  289:  // this matcher object is alive.
        -:  290:  const MatcherDescriberInterface* GetDescriber() const {
        -:  291:    return impl_.get();
        -:  292:  }
        -:  293:
        -:  294: protected:
    #####:  295:  MatcherBase() {}
------------------
_ZN7testing8internal11MatcherBaseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEC2Ev:
    #####:  295:  MatcherBase() {}
    %%%%%:  295-block  0
------------------
_ZN7testing8internal11MatcherBaseIRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEC2Ev:
    #####:  295:  MatcherBase() {}
    %%%%%:  295-block  0
------------------
        -:  296:
        -:  297:  // Constructs a matcher from its implementation.
    #####:  298:  explicit MatcherBase(const MatcherInterface<const T&>* impl) : impl_(impl) {}
------------------
_ZN7testing8internal11MatcherBaseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEC2EPKNS_16MatcherInterfaceIRKS7_EE:
    #####:  298:  explicit MatcherBase(const MatcherInterface<const T&>* impl) : impl_(impl) {}
    %%%%%:  298-block  0
------------------
_ZN7testing8internal11MatcherBaseIRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEC2EPKNS_16MatcherInterfaceIS9_EE:
    #####:  298:  explicit MatcherBase(const MatcherInterface<const T&>* impl) : impl_(impl) {}
    %%%%%:  298-block  0
------------------
        -:  299:
        -:  300:  template <typename U>
        -:  301:  explicit MatcherBase(
        -:  302:      const MatcherInterface<U>* impl,
        -:  303:      typename std::enable_if<!std::is_same<U, const U&>::value>::type* =
        -:  304:          nullptr)
        -:  305:      : impl_(new internal::MatcherInterfaceAdapter<U>(impl)) {}
        -:  306:
        -:  307:  MatcherBase(const MatcherBase&) = default;
        -:  308:  MatcherBase& operator=(const MatcherBase&) = default;
    #####:  309:  MatcherBase(MatcherBase&&) = default;
    %%%%%:  309-block  0
        -:  310:  MatcherBase& operator=(MatcherBase&&) = default;
        -:  311:
    #####:  312:  virtual ~MatcherBase() {}
------------------
_ZN7testing8internal11MatcherBaseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEED0Ev:
    #####:  312:  virtual ~MatcherBase() {}
    %%%%%:  312-block  0
------------------
_ZN7testing8internal11MatcherBaseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEED2Ev:
    #####:  312:  virtual ~MatcherBase() {}
    %%%%%:  312-block  0
------------------
_ZN7testing8internal11MatcherBaseIRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEED0Ev:
    #####:  312:  virtual ~MatcherBase() {}
    %%%%%:  312-block  0
------------------
_ZN7testing8internal11MatcherBaseIRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEED2Ev:
    #####:  312:  virtual ~MatcherBase() {}
    %%%%%:  312-block  0
------------------
        -:  313:
        -:  314: private:
        -:  315:  std::shared_ptr<const MatcherInterface<const T&>> impl_;
        -:  316:};
        -:  317:
        -:  318:}  // namespace internal
        -:  319:
        -:  320:// A Matcher<T> is a copyable and IMMUTABLE (except by assignment)
        -:  321:// object that can check whether a value of type T matches.  The
        -:  322:// implementation of Matcher<T> is just a std::shared_ptr to const
        -:  323:// MatcherInterface<T>.  Don't inherit from Matcher!
        -:  324:template <typename T>
        -:  325:class Matcher : public internal::MatcherBase<T> {
        -:  326: public:
        -:  327:  // Constructs a null matcher.  Needed for storing Matcher objects in STL
        -:  328:  // containers.  A default-constructed matcher is not yet initialized.  You
        -:  329:  // cannot use it until a valid value has been assigned to it.
        -:  330:  explicit Matcher() {}  // NOLINT
        -:  331:
        -:  332:  // Constructs a matcher from its implementation.
        -:  333:  explicit Matcher(const MatcherInterface<const T&>* impl)
        -:  334:      : internal::MatcherBase<T>(impl) {}
        -:  335:
        -:  336:  template <typename U>
        -:  337:  explicit Matcher(
        -:  338:      const MatcherInterface<U>* impl,
        -:  339:      typename std::enable_if<!std::is_same<U, const U&>::value>::type* =
        -:  340:          nullptr)
        -:  341:      : internal::MatcherBase<T>(impl) {}
        -:  342:
        -:  343:  // Implicit constructor here allows people to write
        -:  344:  // EXPECT_CALL(foo, Bar(5)) instead of EXPECT_CALL(foo, Bar(Eq(5))) sometimes
        -:  345:  Matcher(T value);  // NOLINT
        -:  346:};
        -:  347:
        -:  348:// The following two specializations allow the user to write str
        -:  349:// instead of Eq(str) and "foo" instead of Eq("foo") when a std::string
        -:  350:// matcher is expected.
        -:  351:template <>
        -:  352:class GTEST_API_ Matcher<const std::string&>
        -:  353:    : public internal::MatcherBase<const std::string&> {
        -:  354: public:
        -:  355:  Matcher() {}
        -:  356:
    #####:  357:  explicit Matcher(const MatcherInterface<const std::string&>* impl)
    #####:  358:      : internal::MatcherBase<const std::string&>(impl) {}
    %%%%%:  358-block  0
        -:  359:
        -:  360:  // Allows the user to write str instead of Eq(str) sometimes, where
        -:  361:  // str is a std::string object.
        -:  362:  Matcher(const std::string& s);  // NOLINT
        -:  363:
        -:  364:  // Allows the user to write "foo" instead of Eq("foo") sometimes.
        -:  365:  Matcher(const char* s);  // NOLINT
        -:  366:};
        -:  367:
        -:  368:template <>
        -:  369:class GTEST_API_ Matcher<std::string>
        -:  370:    : public internal::MatcherBase<std::string> {
        -:  371: public:
        -:  372:  Matcher() {}
        -:  373:
    #####:  374:  explicit Matcher(const MatcherInterface<const std::string&>* impl)
    #####:  375:      : internal::MatcherBase<std::string>(impl) {}
    %%%%%:  375-block  0
        -:  376:  explicit Matcher(const MatcherInterface<std::string>* impl)
        -:  377:      : internal::MatcherBase<std::string>(impl) {}
        -:  378:
        -:  379:  // Allows the user to write str instead of Eq(str) sometimes, where
        -:  380:  // str is a string object.
        -:  381:  Matcher(const std::string& s);  // NOLINT
        -:  382:
        -:  383:  // Allows the user to write "foo" instead of Eq("foo") sometimes.
        -:  384:  Matcher(const char* s);  // NOLINT
        -:  385:};
        -:  386:
        -:  387:#if GTEST_INTERNAL_HAS_STRING_VIEW
        -:  388:// The following two specializations allow the user to write str
        -:  389:// instead of Eq(str) and "foo" instead of Eq("foo") when a absl::string_view
        -:  390:// matcher is expected.
        -:  391:template <>
        -:  392:class GTEST_API_ Matcher<const internal::StringView&>
        -:  393:    : public internal::MatcherBase<const internal::StringView&> {
        -:  394: public:
        -:  395:  Matcher() {}
        -:  396:
        -:  397:  explicit Matcher(const MatcherInterface<const internal::StringView&>* impl)
        -:  398:      : internal::MatcherBase<const internal::StringView&>(impl) {}
        -:  399:
        -:  400:  // Allows the user to write str instead of Eq(str) sometimes, where
        -:  401:  // str is a std::string object.
        -:  402:  Matcher(const std::string& s);  // NOLINT
        -:  403:
        -:  404:  // Allows the user to write "foo" instead of Eq("foo") sometimes.
        -:  405:  Matcher(const char* s);  // NOLINT
        -:  406:
        -:  407:  // Allows the user to pass absl::string_views or std::string_views directly.
        -:  408:  Matcher(internal::StringView s);  // NOLINT
        -:  409:};
        -:  410:
        -:  411:template <>
        -:  412:class GTEST_API_ Matcher<internal::StringView>
        -:  413:    : public internal::MatcherBase<internal::StringView> {
        -:  414: public:
        -:  415:  Matcher() {}
        -:  416:
        -:  417:  explicit Matcher(const MatcherInterface<const internal::StringView&>* impl)
        -:  418:      : internal::MatcherBase<internal::StringView>(impl) {}
        -:  419:  explicit Matcher(const MatcherInterface<internal::StringView>* impl)
        -:  420:      : internal::MatcherBase<internal::StringView>(impl) {}
        -:  421:
        -:  422:  // Allows the user to write str instead of Eq(str) sometimes, where
        -:  423:  // str is a std::string object.
        -:  424:  Matcher(const std::string& s);  // NOLINT
        -:  425:
        -:  426:  // Allows the user to write "foo" instead of Eq("foo") sometimes.
        -:  427:  Matcher(const char* s);  // NOLINT
        -:  428:
        -:  429:  // Allows the user to pass absl::string_views or std::string_views directly.
        -:  430:  Matcher(internal::StringView s);  // NOLINT
        -:  431:};
        -:  432:#endif  // GTEST_INTERNAL_HAS_STRING_VIEW
        -:  433:
        -:  434:// Prints a matcher in a human-readable format.
        -:  435:template <typename T>
        -:  436:std::ostream& operator<<(std::ostream& os, const Matcher<T>& matcher) {
        -:  437:  matcher.DescribeTo(&os);
        -:  438:  return os;
        -:  439:}
        -:  440:
        -:  441:// The PolymorphicMatcher class template makes it easy to implement a
        -:  442:// polymorphic matcher (i.e. a matcher that can match values of more
        -:  443:// than one type, e.g. Eq(n) and NotNull()).
        -:  444://
        -:  445:// To define a polymorphic matcher, a user should provide an Impl
        -:  446:// class that has a DescribeTo() method and a DescribeNegationTo()
        -:  447:// method, and define a member function (or member function template)
        -:  448://
        -:  449://   bool MatchAndExplain(const Value& value,
        -:  450://                        MatchResultListener* listener) const;
        -:  451://
        -:  452:// See the definition of NotNull() for a complete example.
        -:  453:template <class Impl>
        -:  454:class PolymorphicMatcher {
        -:  455: public:
        -:  456:  explicit PolymorphicMatcher(const Impl& an_impl) : impl_(an_impl) {}
        -:  457:
        -:  458:  // Returns a mutable reference to the underlying matcher
        -:  459:  // implementation object.
        -:  460:  Impl& mutable_impl() { return impl_; }
        -:  461:
        -:  462:  // Returns an immutable reference to the underlying matcher
        -:  463:  // implementation object.
        -:  464:  const Impl& impl() const { return impl_; }
        -:  465:
        -:  466:  template <typename T>
        -:  467:  operator Matcher<T>() const {
        -:  468:    return Matcher<T>(new MonomorphicImpl<const T&>(impl_));
        -:  469:  }
        -:  470:
        -:  471: private:
        -:  472:  template <typename T>
        -:  473:  class MonomorphicImpl : public MatcherInterface<T> {
        -:  474:   public:
        -:  475:    explicit MonomorphicImpl(const Impl& impl) : impl_(impl) {}
        -:  476:
        -:  477:    void DescribeTo(::std::ostream* os) const override { impl_.DescribeTo(os); }
        -:  478:
        -:  479:    void DescribeNegationTo(::std::ostream* os) const override {
        -:  480:      impl_.DescribeNegationTo(os);
        -:  481:    }
        -:  482:
        -:  483:    bool MatchAndExplain(T x, MatchResultListener* listener) const override {
        -:  484:      return impl_.MatchAndExplain(x, listener);
        -:  485:    }
        -:  486:
        -:  487:   private:
        -:  488:    const Impl impl_;
        -:  489:  };
        -:  490:
        -:  491:  Impl impl_;
        -:  492:};
        -:  493:
        -:  494:// Creates a matcher from its implementation.
        -:  495:// DEPRECATED: Especially in the generic code, prefer:
        -:  496://   Matcher<T>(new MyMatcherImpl<const T&>(...));
        -:  497://
        -:  498:// MakeMatcher may create a Matcher that accepts its argument by value, which
        -:  499:// leads to unnecessary copies & lack of support for non-copyable types.
        -:  500:template <typename T>
        -:  501:inline Matcher<T> MakeMatcher(const MatcherInterface<T>* impl) {
        -:  502:  return Matcher<T>(impl);
        -:  503:}
        -:  504:
        -:  505:// Creates a polymorphic matcher from its implementation.  This is
        -:  506:// easier to use than the PolymorphicMatcher<Impl> constructor as it
        -:  507:// doesn't require you to explicitly write the template argument, e.g.
        -:  508://
        -:  509://   MakePolymorphicMatcher(foo);
        -:  510:// vs
        -:  511://   PolymorphicMatcher<TypeOfFoo>(foo);
        -:  512:template <class Impl>
        -:  513:inline PolymorphicMatcher<Impl> MakePolymorphicMatcher(const Impl& impl) {
        -:  514:  return PolymorphicMatcher<Impl>(impl);
        -:  515:}
        -:  516:
        -:  517:namespace internal {
        -:  518:// Implements a matcher that compares a given value with a
        -:  519:// pre-supplied value using one of the ==, <=, <, etc, operators.  The
        -:  520:// two values being compared don't have to have the same type.
        -:  521://
        -:  522:// The matcher defined here is polymorphic (for example, Eq(5) can be
        -:  523:// used to match an int, a short, a double, etc).  Therefore we use
        -:  524:// a template type conversion operator in the implementation.
        -:  525://
        -:  526:// The following template definition assumes that the Rhs parameter is
        -:  527:// a "bare" type (i.e. neither 'const T' nor 'T&').
        -:  528:template <typename D, typename Rhs, typename Op>
        -:  529:class ComparisonBase {
        -:  530: public:
    #####:  531:  explicit ComparisonBase(const Rhs& rhs) : rhs_(rhs) {}
    %%%%%:  531-block  0
        -:  532:  template <typename Lhs>
    #####:  533:  operator Matcher<Lhs>() const {
    #####:  534:    return Matcher<Lhs>(new Impl<const Lhs&>(rhs_));
        -:  535:  }
------------------
_ZNK7testing8internal14ComparisonBaseINS0_9EqMatcherINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEES8_NS0_5AnyEqEEcvNS_7MatcherIT_EEIS8_EEv:
    #####:  533:  operator Matcher<Lhs>() const {
    #####:  534:    return Matcher<Lhs>(new Impl<const Lhs&>(rhs_));
    %%%%%:  534-block  0
    %%%%%:  534-block  1
    $$$$$:  534-block  2
        -:  535:  }
------------------
_ZNK7testing8internal14ComparisonBaseINS0_9EqMatcherINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEES8_NS0_5AnyEqEEcvNS_7MatcherIT_EEIRKS8_EEv:
    #####:  533:  operator Matcher<Lhs>() const {
    #####:  534:    return Matcher<Lhs>(new Impl<const Lhs&>(rhs_));
    %%%%%:  534-block  0
    %%%%%:  534-block  1
    $$$$$:  534-block  2
        -:  535:  }
------------------
        -:  536:
        -:  537: private:
        -:  538:  template <typename T>
    #####:  539:  static const T& Unwrap(const T& v) { return v; }
    %%%%%:  539-block  0
        -:  540:  template <typename T>
        -:  541:  static const T& Unwrap(std::reference_wrapper<T> v) { return v; }
        -:  542:
        -:  543:  template <typename Lhs, typename = Rhs>
        -:  544:  class Impl : public MatcherInterface<Lhs> {
        -:  545:   public:
    #####:  546:    explicit Impl(const Rhs& rhs) : rhs_(rhs) {}
    %%%%%:  546-block  0
    %%%%%:  546-block  1
    $$$$$:  546-block  2
    #####:  547:    bool MatchAndExplain(Lhs lhs,
        -:  548:                         MatchResultListener* /* listener */) const override {
    #####:  549:      return Op()(lhs, Unwrap(rhs_));
    %%%%%:  549-block  0
        -:  550:    }
    #####:  551:    void DescribeTo(::std::ostream* os) const override {
    #####:  552:      *os << D::Desc() << " ";
    %%%%%:  552-block  0
    #####:  553:      UniversalPrint(Unwrap(rhs_), os);
    #####:  554:    }
    #####:  555:    void DescribeNegationTo(::std::ostream* os) const override {
    #####:  556:      *os << D::NegatedDesc() <<  " ";
    %%%%%:  556-block  0
    #####:  557:      UniversalPrint(Unwrap(rhs_), os);
    #####:  558:    }
        -:  559:
        -:  560:   private:
        -:  561:    Rhs rhs_;
        -:  562:  };
        -:  563:  Rhs rhs_;
        -:  564:};
        -:  565:
        -:  566:template <typename Rhs>
        -:  567:class EqMatcher : public ComparisonBase<EqMatcher<Rhs>, Rhs, AnyEq> {
        -:  568: public:
    #####:  569:  explicit EqMatcher(const Rhs& rhs)
    #####:  570:      : ComparisonBase<EqMatcher<Rhs>, Rhs, AnyEq>(rhs) { }
    %%%%%:  570-block  0
    #####:  571:  static const char* Desc() { return "is equal to"; }
    %%%%%:  571-block  0
    #####:  572:  static const char* NegatedDesc() { return "isn't equal to"; }
    %%%%%:  572-block  0
        -:  573:};
        -:  574:template <typename Rhs>
        -:  575:class NeMatcher : public ComparisonBase<NeMatcher<Rhs>, Rhs, AnyNe> {
        -:  576: public:
        -:  577:  explicit NeMatcher(const Rhs& rhs)
        -:  578:      : ComparisonBase<NeMatcher<Rhs>, Rhs, AnyNe>(rhs) { }
        -:  579:  static const char* Desc() { return "isn't equal to"; }
        -:  580:  static const char* NegatedDesc() { return "is equal to"; }
        -:  581:};
        -:  582:template <typename Rhs>
        -:  583:class LtMatcher : public ComparisonBase<LtMatcher<Rhs>, Rhs, AnyLt> {
        -:  584: public:
        -:  585:  explicit LtMatcher(const Rhs& rhs)
        -:  586:      : ComparisonBase<LtMatcher<Rhs>, Rhs, AnyLt>(rhs) { }
        -:  587:  static const char* Desc() { return "is <"; }
        -:  588:  static const char* NegatedDesc() { return "isn't <"; }
        -:  589:};
        -:  590:template <typename Rhs>
        -:  591:class GtMatcher : public ComparisonBase<GtMatcher<Rhs>, Rhs, AnyGt> {
        -:  592: public:
        -:  593:  explicit GtMatcher(const Rhs& rhs)
        -:  594:      : ComparisonBase<GtMatcher<Rhs>, Rhs, AnyGt>(rhs) { }
        -:  595:  static const char* Desc() { return "is >"; }
        -:  596:  static const char* NegatedDesc() { return "isn't >"; }
        -:  597:};
        -:  598:template <typename Rhs>
        -:  599:class LeMatcher : public ComparisonBase<LeMatcher<Rhs>, Rhs, AnyLe> {
        -:  600: public:
        -:  601:  explicit LeMatcher(const Rhs& rhs)
        -:  602:      : ComparisonBase<LeMatcher<Rhs>, Rhs, AnyLe>(rhs) { }
        -:  603:  static const char* Desc() { return "is <="; }
        -:  604:  static const char* NegatedDesc() { return "isn't <="; }
        -:  605:};
        -:  606:template <typename Rhs>
        -:  607:class GeMatcher : public ComparisonBase<GeMatcher<Rhs>, Rhs, AnyGe> {
        -:  608: public:
        -:  609:  explicit GeMatcher(const Rhs& rhs)
        -:  610:      : ComparisonBase<GeMatcher<Rhs>, Rhs, AnyGe>(rhs) { }
        -:  611:  static const char* Desc() { return "is >="; }
        -:  612:  static const char* NegatedDesc() { return "isn't >="; }
        -:  613:};
        -:  614:
        -:  615:template <typename T, typename = typename std::enable_if<
        -:  616:                          std::is_constructible<std::string, T>::value>::type>
        -:  617:using StringLike = T;
        -:  618:
        -:  619:// Implements polymorphic matchers MatchesRegex(regex) and
        -:  620:// ContainsRegex(regex), which can be used as a Matcher<T> as long as
        -:  621:// T can be converted to a string.
        -:  622:class MatchesRegexMatcher {
        -:  623: public:
        -:  624:  MatchesRegexMatcher(const RE* regex, bool full_match)
        -:  625:      : regex_(regex), full_match_(full_match) {}
        -:  626:
        -:  627:#if GTEST_INTERNAL_HAS_STRING_VIEW
        -:  628:  bool MatchAndExplain(const internal::StringView& s,
        -:  629:                       MatchResultListener* listener) const {
        -:  630:    return MatchAndExplain(std::string(s), listener);
        -:  631:  }
        -:  632:#endif  // GTEST_INTERNAL_HAS_STRING_VIEW
        -:  633:
        -:  634:  // Accepts pointer types, particularly:
        -:  635:  //   const char*
        -:  636:  //   char*
        -:  637:  //   const wchar_t*
        -:  638:  //   wchar_t*
        -:  639:  template <typename CharType>
        -:  640:  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {
        -:  641:    return s != nullptr && MatchAndExplain(std::string(s), listener);
        -:  642:  }
        -:  643:
        -:  644:  // Matches anything that can convert to std::string.
        -:  645:  //
        -:  646:  // This is a template, not just a plain function with const std::string&,
        -:  647:  // because absl::string_view has some interfering non-explicit constructors.
        -:  648:  template <class MatcheeStringType>
        -:  649:  bool MatchAndExplain(const MatcheeStringType& s,
        -:  650:                       MatchResultListener* /* listener */) const {
        -:  651:    const std::string& s2(s);
        -:  652:    return full_match_ ? RE::FullMatch(s2, *regex_)
        -:  653:                       : RE::PartialMatch(s2, *regex_);
        -:  654:  }
        -:  655:
        -:  656:  void DescribeTo(::std::ostream* os) const {
        -:  657:    *os << (full_match_ ? "matches" : "contains") << " regular expression ";
        -:  658:    UniversalPrinter<std::string>::Print(regex_->pattern(), os);
        -:  659:  }
        -:  660:
        -:  661:  void DescribeNegationTo(::std::ostream* os) const {
        -:  662:    *os << "doesn't " << (full_match_ ? "match" : "contain")
        -:  663:        << " regular expression ";
        -:  664:    UniversalPrinter<std::string>::Print(regex_->pattern(), os);
        -:  665:  }
        -:  666:
        -:  667: private:
        -:  668:  const std::shared_ptr<const RE> regex_;
        -:  669:  const bool full_match_;
        -:  670:};
        -:  671:}  // namespace internal
        -:  672:
        -:  673:// Matches a string that fully matches regular expression 'regex'.
        -:  674:// The matcher takes ownership of 'regex'.
        -:  675:inline PolymorphicMatcher<internal::MatchesRegexMatcher> MatchesRegex(
        -:  676:    const internal::RE* regex) {
        -:  677:  return MakePolymorphicMatcher(internal::MatchesRegexMatcher(regex, true));
        -:  678:}
        -:  679:template <typename T = std::string>
        -:  680:PolymorphicMatcher<internal::MatchesRegexMatcher> MatchesRegex(
        -:  681:    const internal::StringLike<T>& regex) {
        -:  682:  return MatchesRegex(new internal::RE(std::string(regex)));
        -:  683:}
        -:  684:
        -:  685:// Matches a string that contains regular expression 'regex'.
        -:  686:// The matcher takes ownership of 'regex'.
        -:  687:inline PolymorphicMatcher<internal::MatchesRegexMatcher> ContainsRegex(
        -:  688:    const internal::RE* regex) {
        -:  689:  return MakePolymorphicMatcher(internal::MatchesRegexMatcher(regex, false));
        -:  690:}
        -:  691:template <typename T = std::string>
        -:  692:PolymorphicMatcher<internal::MatchesRegexMatcher> ContainsRegex(
        -:  693:    const internal::StringLike<T>& regex) {
        -:  694:  return ContainsRegex(new internal::RE(std::string(regex)));
        -:  695:}
        -:  696:
        -:  697:// Creates a polymorphic matcher that matches anything equal to x.
        -:  698:// Note: if the parameter of Eq() were declared as const T&, Eq("foo")
        -:  699:// wouldn't compile.
        -:  700:template <typename T>
    #####:  701:inline internal::EqMatcher<T> Eq(T x) { return internal::EqMatcher<T>(x); }
    %%%%%:  701-block  0
        -:  702:
        -:  703:// Constructs a Matcher<T> from a 'value' of type T.  The constructed
        -:  704:// matcher matches any value that's equal to 'value'.
        -:  705:template <typename T>
        -:  706:Matcher<T>::Matcher(T value) { *this = Eq(value); }
        -:  707:
        -:  708:// Creates a monomorphic matcher that matches anything with type Lhs
        -:  709:// and equal to rhs.  A user may need to use this instead of Eq(...)
        -:  710:// in order to resolve an overloading ambiguity.
        -:  711://
        -:  712:// TypedEq<T>(x) is just a convenient short-hand for Matcher<T>(Eq(x))
        -:  713:// or Matcher<T>(x), but more readable than the latter.
        -:  714://
        -:  715:// We could define similar monomorphic matchers for other comparison
        -:  716:// operations (e.g. TypedLt, TypedGe, and etc), but decided not to do
        -:  717:// it yet as those are used much less than Eq() in practice.  A user
        -:  718:// can always write Matcher<T>(Lt(5)) to be explicit about the type,
        -:  719:// for example.
        -:  720:template <typename Lhs, typename Rhs>
        -:  721:inline Matcher<Lhs> TypedEq(const Rhs& rhs) { return Eq(rhs); }
        -:  722:
        -:  723:// Creates a polymorphic matcher that matches anything >= x.
        -:  724:template <typename Rhs>
        -:  725:inline internal::GeMatcher<Rhs> Ge(Rhs x) {
        -:  726:  return internal::GeMatcher<Rhs>(x);
        -:  727:}
        -:  728:
        -:  729:// Creates a polymorphic matcher that matches anything > x.
        -:  730:template <typename Rhs>
        -:  731:inline internal::GtMatcher<Rhs> Gt(Rhs x) {
        -:  732:  return internal::GtMatcher<Rhs>(x);
        -:  733:}
        -:  734:
        -:  735:// Creates a polymorphic matcher that matches anything <= x.
        -:  736:template <typename Rhs>
        -:  737:inline internal::LeMatcher<Rhs> Le(Rhs x) {
        -:  738:  return internal::LeMatcher<Rhs>(x);
        -:  739:}
        -:  740:
        -:  741:// Creates a polymorphic matcher that matches anything < x.
        -:  742:template <typename Rhs>
        -:  743:inline internal::LtMatcher<Rhs> Lt(Rhs x) {
        -:  744:  return internal::LtMatcher<Rhs>(x);
        -:  745:}
        -:  746:
        -:  747:// Creates a polymorphic matcher that matches anything != x.
        -:  748:template <typename Rhs>
        -:  749:inline internal::NeMatcher<Rhs> Ne(Rhs x) {
        -:  750:  return internal::NeMatcher<Rhs>(x);
        -:  751:}
        -:  752:}  // namespace testing
        -:  753:
        -:  754:GTEST_DISABLE_MSC_WARNINGS_POP_()  //  4251 5046
        -:  755:
        -:  756:#endif  // GTEST_INCLUDE_GTEST_GTEST_MATCHERS_H_
